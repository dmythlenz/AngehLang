from qiskit import QuantumCircuit  
def generate_qasm(ast):  
    qc = QuantumCircuit(2)  
    qc.h(0)  
    qc.cx(0, 1)  
    return qc.qasm()  
"""
Quantum Intermediate Representation (QIR) Generator for AngehLang
Translates high-level quantum operations into QIR for execution on quantum hardware/simulators.
"""

from enum import Enum
from typing import List, Dict

class Qubit:
    """Track allocated qubits and their QIR references."""
    def __init__(self, name: str, index: int):
        self.name = name
        self.index = index
        self.qir_ref = f"%qubit_{index}"

class QuantumGate(Enum):
    """Supported quantum gates and their QIR function mappings."""
    H = "__quantum__qis__h__body"
    X = "__quantum__qis__x__body"
    CNOT = "__quantum__qis__cnot__body"
    MEASURE = "__quantum__qis__mz__body"

class QIRGenerator:
    def __init__(self):
        self.qubits: Dict[str, Qubit] = {}  # Track qubit allocations
        self.classical_regs: Dict[str, str] = {}  # Classical registers for measurements
        self.qir_code: List[str] = []  # Generated QIR lines
        self.qubit_counter = 0
        self.reg_counter = 0

    def _allocate_qubit(self, name: str) -> Qubit:
        """Allocate a qubit and return its QIR reference."""
        if name in self.qubits:
            raise ValueError(f"Qubit {name} already declared.")
        qubit = Qubit(name, self.qubit_counter)
        self.qubits[name] = qubit
        self.qir_code.append(f"{qubit.qir_ref} = call %Qubit* @__quantum__rt__qubit_allocate()")
        self.qubit_counter += 1
        return qubit

    def _apply_gate(self, gate: QuantumGate, qubit_names: List[str]):
        """Apply a quantum gate to one or more qubits."""
        if gate == QuantumGate.CNOT and len(qubit_names) != 2:
            raise ValueError("CNOT gate requires exactly 2 qubits.")
        
        qubit_refs = []
        for name in qubit_names:
            if name not in self.qubits:
                raise ValueError(f"Qubit {name} not allocated.")
            qubit_refs.append(self.qubits[name].qir_ref)
        
        if gate == QuantumGate.CNOT:
            self.qir_code.append(f"call void @{gate.value}(%Qubit* {qubit_refs[0]}, %Qubit* {qubit_refs[1]})")
        else:
            self.qir_code.append(f"call void @{gate.value}(%Qubit* {qubit_refs[0]})")

    def _measure_qubit(self, qubit_name: str, result_var: str):
        """Measure a qubit and store the result in a classical register."""
        if qubit_name not in self.qubits:
            raise ValueError(f"Qubit {qubit_name} not allocated.")
        if result_var in self.classical_regs:
            raise ValueError(f"Classical register {result_var} already exists.")
        
        reg_ref = f"%creg_{self.reg_counter}"
        self.classical_regs[result_var] = reg_ref
        self.reg_counter += 1
        
        self.qir_code.extend([
            f"{reg_ref} = alloca i1",
            f"call void @{QuantumGate.MEASURE.value}(%Qubit* {self.qubits[qubit_name].qir_ref}, i1* {reg_ref})"
        ])

    def generate_qir(self, ast: List[Dict]) -> str:
        """
        Generate QIR code from AngehLang's quantum AST.
        AST Example:
        [
            {"type": "qubit_declaration", "name": "q1"},
            {"type": "qubit_declaration", "name": "q2"},
            {"type": "gate", "gate": "h", "targets": ["q1"]},
            {"type": "gate", "gate": "cnot", "targets": ["q1", "q2"]},
            {"type": "measure", "qubit": "q1", "result": "result"}
        ]
        """
        self.qir_code.append("; QIR generated by AngehLang")
        self.qir_code.append('declare %Qubit* @__quantum__rt__qubit_allocate()')
        self.qir_code.append('declare void @__quantum__rt__qubit_release(%Qubit*)')
        
        for node in ast:
            if node["type"] == "qubit_declaration":
                self._allocate_qubit(node["name"])
            elif node["type"] == "gate":
                gate = QuantumGate[node["gate"].upper()]
                self._apply_gate(gate, node["targets"])
            elif node["type"] == "measure":
                self._measure_qubit(node["qubit"], node["result"])
        
        # Release all qubits at the end
        for qubit in self.qubits.values():
            self.qir_code.append(f"call void @__quantum__rt__qubit_release(%Qubit* {qubit.qir_ref})")
        
        return '\n'.join(self.qir_code)

# Example Usage
if __name__ == "__main__":
    ast_example = [
        {"type": "qubit_declaration", "name": "q1"},
        {"type": "qubit_declaration", "name": "q2"},
        {"type": "gate", "gate": "h", "targets": ["q1"]},
        {"type": "gate", "gate": "cnot", "targets": ["q1", "q2"]},
        {"type": "measure", "qubit": "q1", "result": "result"}
    ]
    
    generator = QIRGenerator()
    qir = generator.generate_qir(ast_example)
    print(qir)
    class QIRGenerator:
    def __init__(self):
        self.qubit_map = {}
        self.classical_map = {}
        self.qir = ["; QIR Generated by AngehLang"]
        self._add_headers()

    def _add_headers(self):
        self.qir.extend([
            'declare %Qubit* @__quantum__rt__qubit_allocate()',
            'declare void @__quantum__rt__qubit_release(%Qubit*)',
            'declare void @__quantum__qis__h__body(%Qubit*)',
            'declare void @__quantum__qis__cnot__body(%Qubit*, %Qubit*)',
            'declare void @__quantum__qis__mz__body(%Qubit*, i8*)'
        ])

    def process_ast(self, ast):
        for node in ast['quantum_ops']:
            if node['type'] == 'allocate':
                self._allocate_qubit(node['name'])
            elif node['type'] == 'gate':
                self._apply_gate(node['gate'], node['targets'])
            elif node['type'] == 'measure':
                self._add_measurement(node['qubit'], node['cbit'])
        return '\n'.join(self.qir)

    def _allocate_qubit(self, name):
        idx = len(self.qubit_map)
        self.qubit_map[name] = f"%q{idx}"
        self.qir.append(f"{self.qubit_map[name]} = call %Qubit* @__quantum__rt__qubit_allocate()")